// THIS FILE WAS GENERATED BY `xtp-go-bindgen`. DO NOT EDIT.
package main

import (
	<% if (JSON.stringify(schema).includes("enum")) { %>"errors"<% } %>
	<% if (JSON.stringify(schema).includes("date-time")) { %>"time"<% } %>

	pdk "github.com/extism/go-pdk"
)

<% schema.exports.forEach(ex => { -%>
//export <%- ex.name %>
func _<%- goName(ex.name) %>() int32 {
	var err error
	_ = err
  <% if (ex.input) { -%>
    <% if (ex.input.contentType === 'application/json') { -%>
			pdk.Log(pdk.LogDebug, "<%- goName(ex.name) %>: getting JSON input")
			var input <%- toGolangType(ex.input) %>
			err = pdk.InputJSON(&input)
			if err != nil {
				pdk.SetError(err)
				return -1
			}
    <% } else if (ex.input.type === 'string') { -%>
      <% if (ex.input.$ref && ex.input.$ref.enum) { -%>
			pdk.Log(pdk.LogDebug, "<%- goName(ex.name) %>: getting enum string input")
      input, err := stringTo<%- goName(ex.input.$ref.name) %>(pdk.InputString())
      if err != nil {
        pdk.SetError(err)
        return -1
      }
			<% } else { -%>
			pdk.Log(pdk.LogDebug, "<%- goName(ex.name) %>: getting string input")
			input := pdk.InputString()
			<% } %>
    <% } else { -%>
			pdk.Log(pdk.LogDebug, "<%- goName(ex.name) %>: getting bytes input")
      input := pdk.Input()
    <% } -%>

		pdk.Log(pdk.LogDebug, "<%- goName(ex.name) %>: calling implementation function")
    <% if (ex.output) { -%>
      output, err := <%- goName(ex.name) %>(input)
			if err != nil {
				pdk.SetError(err)
				return -1
			}
    <% } else { -%>
      err = <%- goName(ex.name) %>(input)
			if err != nil {
				pdk.SetError(err)
				return -1
			}
    <% } -%>
  <% } else { -%>
    <% if (ex.output) { -%>
      output, err := <%- goName(ex.name) %>()
    <% } else { -%>
      err = <%- goName(ex.name) %>()
    <% } -%>
		if err != nil {
			pdk.SetError(err)
			return -1
		}
  <% } -%>

  <% if (ex.output) { -%>
    <% if (ex.output.contentType === 'application/json') { -%>
			pdk.Log(pdk.LogDebug, "<%- goName(ex.name) %>: setting JSON output")
			err = pdk.OutputJSON(output)
			if err != nil {
				pdk.SetError(err)
				return -1
			}
    <% } else if (ex.output.type === 'string') { -%>
			pdk.Log(pdk.LogDebug, "<%- goName(ex.name) %>: setting string output")
      pdk.OutputString(output)
    <% } else { -%>
			pdk.Log(pdk.LogDebug, "<%- goName(ex.name) %>: setting bytes output")
      pdk.Output(output)
    <% } -%>
  <% } -%>

	pdk.Log(pdk.LogDebug, "<%- goName(ex.name) %>: returning")
  return 0
}

<% }) %>

<% if (schema.imports.length > 0) { %>
	<% Object.values(schema.imports).forEach(im => { %>
		//go:wasmimport extism:host/user <%- im.name %>
		func _<%- goName(im.name) %>(<%- im.input ? "uint64" : null %>) <%- im.output ? "uint64" : null %>
	<% }) %>

	<% } %>
	
	<% Object.values(schema.schemas).forEach(schema => { %>
		<% if (schema.properties.length > 0) { %>
	
	// <%- formatCommentBlock(schema.description, "// ") %>
	type <%- goName(schema.name) %> struct {
		<% schema.properties.forEach(p => { -%>
		<% if (p.description) { -%>
		// <%- formatCommentBlock(p.description, "// ") %>
		<% } -%>
		<%- goName(p.name) %> <%- p.nullable ? pointerToGolangType(p) : toGolangType(p) %> `json:"<%- p.name %>"`
		<% }) %>
	}
		<% } else if (schema.enum) { %>
	
	// <%- formatCommentLine(schema.description) %>
	type <%- goName(schema.name) %> string
	const (
		<% schema.enum.forEach((variant, i) => { -%>
			<%- `${goName(schema.name)}${goName(variant)} ${goName(schema.name)} = "${variant}"` %>
		<% }) -%>
	)

	func (v <%- goName(schema.name) %>) String() string {
		switch (v) {
		<% schema.enum.forEach((variant) => { -%>
		case <%- `${goName(schema.name)}${goName(variant)}` %>:
			return `<%- variant %>`
		<% }) -%>
		default: 
			return ""
		}
	}

	func stringTo<%- goName(schema.name) %>(s string) (<%- goName(schema.name) %>, error) {
		switch (s) {
		<% schema.enum.forEach((variant) => { -%>
		case `<%- variant %>`:
			return <%- `${goName(schema.name)}${goName(variant)}` %>, nil
		<% }) -%>
		default:
			return <%- goName(schema.name) %>(""), errors.New("unable to convert string to <%- `${goName(schema.name)}` %>")
		}
	}

		<% }%>
	<% }) %>


<% schema.imports.forEach(imp => { %>
	<% if (hasComment(imp)) -%>
	// <%- goName(imp.name) %> <%- formatCommentBlock(imp.description, "// ") %>
	<% if (hasComment(imp.input)) { -%>
	// It takes input of <%- toGolangType(imp.input) %> (<%- formatCommentLine(imp.input.description) %>)
	<% } -%>
	<% if (hasComment(imp.output)) { -%>
	// And it returns an output <%- toGolangType(imp.output) %> (<%- formatCommentLine(imp.output.description) %>)
	<% } -%>
	func <%- goName(imp.name) %>(<%- imp.input ? `input ${toGolangType(imp.input)}` : null %>) <%- imp.output ? `(${pointerToGolangType(imp.output)}, error)` : "error" %> {
		var err error
		_ = err
	<% if (imp.input) { -%>
		<% if (imp.input.contentType === 'application/json') { -%>
		mem, err := pdk.AllocateJSON(&input)
		if err != nil {
			return <%- imp.output ? "nil, err" : "err" %>
		}
		<% } else if (imp.input.$ref && imp.input.$ref.enum) { -%>
		mem := pdk.AllocateString(input.String())
		<% } else if (imp.input.contentType === 'text/plain; charset=UTF-8') { -%>
		mem := pdk.AllocateString(input)
		<% } else if (imp.input.type === 'string') { -%>
		mem := pdk.AllocateString(input)
		<% } else { -%>
		mem := pdk.AllocateBytes(input)
		<% } -%>

		<% if (imp.output) { -%>offs :=<% } -%> _<%- goName(imp.name) %>(mem.Offset())
	<% } else { -%>
		<% if (imp.output) { -%>offs :=<% } -%> _<%- goName(imp.name) %>()
	<% } -%>
	
	<% if (imp.output) { -%>
		<% if (imp.output.contentType === 'application/json') { -%>
			var output <%- toGolangType(imp.output) %>
			err = pdk.JSONFrom(offs, &output)
			if err != nil {
				return nil, err
			}
			<% if (imp.output.type === 'object') { -%>
				return output, nil
			<% } else { %>
				return &output, nil
			<% } %>
		<% } else if (imp.output.contentType === 'text/plain; charset=UTF-8') { -%>
			outputMem := pdk.FindMemory(offs)
			return string(outputMem.ReadBytes()), nil
		<% } else if (imp.output.type === 'string') { -%>
			outputMem := pdk.FindMemory(offs)
			out := string(outputMem.ReadBytes())
			return &out, err
		<% } else { -%>
			outputMem := pdk.FindMemory(offs)
			return outputMem.ReadBytes(), nil
		<% } -%>
	<% } else { %>
		return nil
	<% } %>
	}
<% }) %>

// Note: leave this in place, as the Go compiler will find the `export` function as the entrypoint.
func main() {}
